---
title: "Mina o1js tutorial"
description: You are going to learn to develop general purpose zk programs and smart contracts for Mina using o1js in this tutorial.
keywords:
    - o1js
    - mina
    - o1js tutorial
    - mina tutorial
    - berzan
---

---

## Mina

Mina is a very lighweight blockchain.

It only requires a fixed size of 22KB to verify your own account without trusting any node.

Mina is based on zero knowledge proofs to achieve that.

## Zero knowledge proofs

Zero knowledge proofs are used to prove that something is correct without revealing some secret information.

Zero knowledge proofs are generated by prover functions and verified with verification keys.

## Prover functions

A prover function takes some secret and public parameters and returns a zero knowledge proof based on its logic.

## Verification keys

Each prover function has a unique verification key.

Verification keys are used to check if a zero knowledge proof is valid.

## o1js

o1js is a TypeScript library to write zk programs and smart contracts for Mina.

It uses Snarky under the hood, an OCaml library for verifiable computation.

## Zk programs

A zk program is a combination of methods.

Each method takes a public input and returns a public output and generates a zero knowledge proof.

A zk program has a single verification key that can be used for any proof.

## Smart contracts

A smart contract is a zk program whose verification key is deployed to Mina blockchain.

Public inputs are stored on-chain and public outputs are used to modify the blockchain state.

## Field element

The basic unit of data in zero knowledge proof programming.

Each field element can store a number up to 255 bits in size.

All the other data types in zero knowledge proof programming are based on field elements.
Some of them are `UInt64`, `UInt32`, `Bool`, `PublicKey`, etc.

---

## Getting started

You only need Node.js v20 or newer installed to start developing on Mina.

In this tutorial, you are going to implement multiple projects.

You can clone my repository to setup all the templates you need with:

```shell
git clone https://github.com/berzanorg/mina-o1js-tutorial.git
```

You can install all the dependencies with:

```shell
npm install
```

You can run tests with:

```shell
npm test
```

All of the tests will fail as the logic isn't implemented yet.

---

## Counter zk program

Open `src/CounterZkProgram.ts` file inside your favorite editor and you will see an empty zk program definition like below.

```ts
export const CounterZkProgram = ZkProgram({
	name: "CounterZkProgram",
	methods: {},
})
```

Each method takes a public input and returns a public output.
In this zk program public input is the latest count and public output is the updated count.
Let's define `publicInput` and `publicOutput` types like below.

```ts
export const CounterZkProgram = ZkProgram({
	...
	publicInput: UInt64,
	publicOutput: UInt64,
})
```

Each method can also take some private inputs or none.
Let's define a method called `genesis` that takes no private inputs but the public input (count) which is returned as the public output (count) without any modifications like below.

```ts
export const CounterZkProgram = ZkProgram({
	...
	methods: {
		genesis: {
			privateInputs: [],
			method(count: UInt64) {
				return count
			},
		},
	},
})
```

Each method generates a zero knowledge proof after being called.
It is required for methods to take the public input and return the public output.
This time we will add a method called `increment` that takes a proof generated by any method as a private input.
It checks if the previous proof is valid, then returns the count plus 1 as the public output. Let's define it like below.

```ts
export const CounterZkProgram = ZkProgram({
	...
	methods: {
		...
		increment: {
			privateInputs: [SelfProof],
			method(count: UInt64, previousProof: SelfProof<UInt64, UInt64>) {
				previousProof.verify()
				count.assertEquals(previousProof.publicOutput)
				return count.add(1)
			},
		},
	},
})
```

Let's define a method called `decrement` that almost does the same operation with `increment` method like below.

```ts
export const CounterZkProgram = ZkProgram({
	...
	methods: {
		...
		decrement: {
			privateInputs: [SelfProof],
			method(count: UInt64, previousProof: SelfProof<UInt64, UInt64>) {
				previousProof.verify()
				count.assertEquals(previousProof.publicOutput)
				return count.sub(1)
			},
		},
	},
})
```

Let's define the last method called `set` that does a similar operation but instead of modifying the existing count, it takes another private input to use as the new count by returning it as the public output.

```ts
export const CounterZkProgram = ZkProgram({
	...
	methods: {
		...
		set: {
			privateInputs: [SelfProof, UInt64],
			method(count: UInt64, previousProof: SelfProof<UInt64, UInt64>, newCount: UInt64) {
				previousProof.verify()
				count.assertEquals(previousProof.publicOutput)
				return newCount
			},
		},
	},
})
```

And that's all! The implementation of a counter zk program is done.

But, we have to write some tests to make sure that it works.

Open `test/CounterZkProgram.test.ts` file and you will see a test like below.

```ts
describe("YourZkProgram", async () => {
	it("can increment the count", async () => {
		assert.fail()
	})

	it("can decrement the count", async () => {
		assert.fail()
	})

	it("can set the count to 42", async () => {
		assert.fail()
	})

	it("can verify the last proof with verification key", async () => {
		assert.fail()
	})
})
```

At first, let's compile our zk program like below.

```ts
describe("CounterZkProgram", async () => {
	const { verificationKey } = await CounterZkProgram.compile()
	...
})
```

Let's call the `genesis` method to generate a proof like below.

```ts
describe("CounterZkProgram", async () => {
	const { verificationKey } = await CounterZkProgram.compile()

	const initialCount = UInt64.from(0)

	let lastProof = await CounterZkProgram.genesis(initialCount)
	...
})
```

In the first test it requires that the count can be incremented.
As you know `increment` method takes a count and a zero knowledge proof as parameters.
We can use `lastProof.publicOutput` as the count. Because it represents the count.
Let's implement the first test's logic like below.

```ts
describe("CounterZkProgram", async () => {
	...
	it("can increment the count", async () => {
		lastProof = await CounterZkProgram.increment(lastProof.publicOutput, lastProof)
		assert.deepEqual(lastProof.publicInput, UInt64.from(0))
		assert.deepEqual(lastProof.publicOutput, UInt64.from(1))
	})
	...
})
```

Let's implement the second test which requires that the count can be decremented.

```ts
describe("CounterZkProgram", async () => {
	...
	it("can decrement the count", async () => {
		lastProof = await CounterZkProgram.decrement(lastProof.publicOutput, lastProof)
		assert.deepEqual(lastProof.publicInput, UInt64.from(1))
		assert.deepEqual(lastProof.publicOutput, UInt64.from(0))
	})
	...
})
```

Let's implement the third test which requires that the count can be set to any number, in this case it is 42.

```ts
describe("CounterZkProgram", async () => {
	...
	it("can set the count to 42", async () => {
		lastProof = await CounterZkProgram.set(lastProof.publicOutput, lastProof, UInt64.from(42))
		assert.deepEqual(lastProof.publicInput, UInt64.from(0))
		assert.deepEqual(lastProof.publicOutput, UInt64.from(42))
	})
	...
})
```

Let's implement the fourth test which requires that the last zero knowledge proof generated can be verified using the verification key of our zk program.

```ts
describe("CounterZkProgram", async () => {
	...
    it("can verify the last proof with verification key", async () => {
    	const isValid = await verify(lastProof, verificationKey)
    	assert.equal(isValid, true)
    })
	...
})
```

---

## Counter smart contract

To be done...

---

## Whitelist smart contract

To be done...

---

## Notes

If you are creating a project from scratch, make sure the properties below are set correctly in your project's `tsconfig.json` file.
Those are needed for o1js to work as expected.

```json
{
	// ...
	"compilerOptions": {
		// ...
		"experimentalDecorators": true,
		"emitDecoratorMetadata": true,
		"useDefineForClassFields": false
		// ...
	}
	// ...
}
```
